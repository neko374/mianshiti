[TOC]



#### 1、闭包

```
闭包就是能够访问到其他函数内部变量的函数

他的优点是：能够私有化变量、防止变量全局污染

他的缺点是：因为闭包会常驻内存，频繁使用闭包会造成内存泄漏

使用场景：定时器、封装变量、回调函数

闭包内存泄漏的原因：由于闭包会将它的外部函数的作用域也保存在内存中，因此会比其他函数更占用内存

闭包内存常驻解决方法：在不使用闭包时，把被引用的变量设置为null，即手动清除变量，这样下次js垃圾回收机制回收时，就会把设为null的量给回收了。
```

 

 

#### 2、什么是vue、vue的双向绑定原理

vue：

```
vue是一个用于创建用户界面的开源JavaScript框架，是一个创建单页面的web应用框架，非常轻巧，高性能；

vue所关注的是MVC（模型视图控制器）模式中的视图层
```



vue核心：

```
vue的核心一个是数据驱动，mvvm，m是model模型，v是view视图，vm是视图模型层用来链接model和view的通信桥梁，一个就是组件化，便于维护和开发
```



vue的双向绑定原理：

```
双向数据绑定是通过数据劫持结合发布者订阅者模式的方式来实现的，通过Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变，Object.defineProperty(obj, prop, descriptor)方法，接收三个参数，分别为obj（定义其上属性的对象）prop（定义或修改的属性）descriptor（具体的改变方法），就是用这个方法来定义一个值，当调用时我们使用了它里面的get方法，当我们给这个属性赋值时，又用到了它里面的set方法
```

 

get：

```
属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值
```



set：

```
属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined
```

 

 

#### 3、Object.defineProperty的缺点：

```
缺点：无法检测到对象属性的添加或删除

原因：vue在创建实例的时候把data深度遍历所有属性,并使用 Object.defineProperty 把这些属性全部转为 getter/setter。让 Vue 追踪依赖，在属性被访问和修改时通知变化。所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。

解决方法： set、delete        Vue.set   this.$set( )
```





#### 4、原型、原型链，为什么要使用原型

```
原型：每一个对象都有一个prototype属性,这个属性指向的是一个对象，就是所谓的原型对象。
原型链：原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推，这个就是原型链，是由__proto__属性串联起来，原型链的尽头是Object.prototype
为什么要用：实现继承，面向对象易读性可维护性好，有易用性，只创建一次就可以，减少内存
```

​		

 

 

#### 5、作用域、作用域链

```
声明在任何函数以外的数据，拥有全局作用域。
 全局作用域的数据，在这条数据声明之后的任何地方都能访问和修改，且只有在页面关闭后才被删除。

函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问，且在函数运行以后被立即删除

当我们调用一条数据的时候，会先在本作用域进行查找，如果找不到就向上查找父作用域，如果还是没有找到，就继续向上，一直找到全局作用域，还是找不到就报错。
```

 

#### 6、http协议

 超文本传输协议

HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口



#### 7、ajax

```
什么是ajax：
	即异步的JavaScript 和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且 	更新部分网页

ajax原理：
	Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面
	
ajax实现过程：

    创建 Ajax的核心对象 XMLHttpRequest对象

    通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接

    构建请求所需的数据内容，并通过XMLHttpRequest 对象的 send() 方法发送给服务器端

    通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态

    接受并处理服务端向客户端响应的数据结果

    将处理结果更新到 HTML页面中


```

 

 

#### 8、axios

```
什么是axios：axios就是通过promise实现对ajax技术的封装
它可以：
	1、发送请求
	2、拦截请求和响应
	3、支持promise API
	4、自动转换JSON数据
	
封装axios
import axios from "axios"; //引入axios

export const request = axios.create({
     // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。
    // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL
    baseURL:'http://shihn.natapp1.cc/',
    // `timeout` 指定请求超时的毫秒数。
    // 如果请求时间超过 `timeout` 的值，则请求会被中断
    timeout:10000 // 默认值是 `0` (永不超时)
})
```

 

#### 9、axios拦截

```
分为响应拦截和请求拦截
响应拦截
axios.interceptors.response.use
请求拦截
axios.interceptors.request.use
```

 

 

 

#### 10、复杂数据如何处理的

```
扁平化数据管理，循环、递归
```

 

#### 11、promise的理解

```
promise是用于解决异步编程的一种新的解决方案，可以理解为是一个容器，里面保存着某个未来结束事件的结果，他有三种状态pending、resolved、rejected
pending是表示在进行中，是初始状态，如果异步操作已完成会进入resolved成功状态，如果异步操作未完成就会进入rejected失败状态，且这个状态是不可逆，不可再改变的
当状态落定后 then方法中的处理程序才会执行，then方法接收两个参数，一个是onresolved一个是onrejected，通过这两个参数拿到成功和失败结果，同时then也会返回一个新的promise实例对象
catch方法就是一个语法题，当promise有异常时执行
如果不管执行结果都希望运行一个方法在.finally执行
```

**promise方法：**

promise.all： 等待所有都完成（或第一个失败）

Promise.any() ：接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和AggregateError类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起。本质上，这个方法和Promise.all()是相反的。

promise.race ：函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。

 

#### 12、react是什么，与vue的区别

 

 

 

- 数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流
- 数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据
- 组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数
- diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM

 

 

 

 

 

#### 13、vue3与vue2的区别

Vue3.0 摒弃了 Object.defineProperty，改为基于 Proxy 的观察者机制探索。

 

首先说一下 Object.defineProperty 的缺点：

 

①Object.defineProperty 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实施响应。

②Object.defineProperty 只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历。Vue2.X 里，是通过递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历，显然如果能劫持一个完整的对象才是更好的选择。

而要取代它的 Proxy 有以下两个优点

可以劫持整个对象，并返回一个新对象。

有多种劫持操作(13 种)

补充：

Proxy 是 ES6 新增的一个属性，翻译过来的意思就是代理，用在这里表示由它来“代理”某些操作。Proxy 让我们能够以简洁易懂的方式控制外部对象的访问，其功能非常类似于设计模式中的代理模式。

Proxy 可以理解为，在目标对象之前设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑(如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等)。从而可以让对象只需要关注核心逻辑，达到关注点分离，降低对象复杂度等目的。

 

 

 

#### 14、强制类型转换、隐式类型转换

```
强制：
	parseInt()
	parseFloat()
	Number()
	String()
	Boolean()
	

隐式：
	算术运算
	==
	>
	<
	
```

 

 

#### 15、字符串api

```
1.字符串.length         字符串的长度（空格逗号也会算进去）
2.字符串.split()        字符串转换为数组，根据括号内的字符进行分割
3.字符串.charAt()       返回指定下标处的字符(没有会显示空白)
4.字符串.charCodeAt()   返回指定下标处的unicode编码
5.字符串.indexOf()      查找指定字符串是否存在  存在返回首次出现的下标，不存在返回-1
6.字符串.lastIndexOf()  查找指定字符串是否存在  存在返回最后一次出现的下标，不存在返回-1
7.字符串.substr()       截取字符串  原字符串不变
                       	如果有一个参数 表示从当前下标开始截取到末尾
                       	如果有2个参数  第二个参数表示的是截取的个数
		substring()
```

 

 

#### 16、数组api

```
1.数组.includes()          查看数组内是否含有指定成员，有就返回true,没有就返回false
2.Array.isArray()         查看括号内的数据格式是否为数组 是返回true，不是返回false
3.数组.indexof()           查看数组内的成员是否存在，存在就返回首次出现的下标 不存在返回-1
4.数组.lastIndexOf()       查看数组内的成员是否存在，存在就返回最后一次出现的下标 不存在返回-1
5.数组.join()              在数组各成员之间插入相同的字符（默认逗号），并且将数组转换为字符串（原数组不							 改变）
6.数组.push()              在数组末尾添加新成员，返回添加后的数组长度（原数组改变）
7.数组.unshift()           在数组开头添加新成员，返回添加后的数组长度（原数组改变）
8.数组.pop()               除数组的最后一个成员,返回被删除的成员（原数组改变）
9.数组.shift()             删除数组的第一个成员,返回被删除的成员（原数组改变）
10.数组.reverse()          反转数组 返回反转后的新数组（原数组改变）
11.数组.sort()             排序数组（默认排列字母--序号） 括号内可以传入自定义函数，定义排列规则
12.数组.splice()           当括号内有一个参数的时候 从当前下标开始截取的末尾，返回截取的内容
                          当括号内有两个参数的时候 从当前下标开始截取几个，返回截取的内容
                          当括号内有三个参数的时候 从当前参数表示正在删除的位置添加内容
13.数组.slice()        	 当括号内有一个参数的时候 从当前下标开始截取到末尾 返回截取的内容（原数组不							  改变）
                      	  当括号内有两个参数的时候 第二个参数表示结束的下标 不包含结束下标 返回截取的						   内容（原数组不改变）
```

 

####  17、节点操作

```
js中：
    查找节点
        节点.parentNode                 当前节点的父节点
        父节点.children                 当前节点的所有子元素节点
        父节点.childNodes               当前节点的所有子节点（包含文本节点） 返回nodelist数组
        父节点.firstChild               当前节点的第一个节点（包含文本节点）
        父节点.firstElementChild        当前节点的第一个元素节点
        父节点.lastChild                当前节点的最后一个节点（包含文本节点）
        父节点.lastElementChild         当前节点的最后一个元素节点
        节点.previousSibling            当前节点的前一个兄弟节点（包含文本节点）
        节点.previousElementSibling     当前节点的前一个兄弟元素节点
        节点.nextSibling                当前节点的最后一个兄弟节点（包含文本节点）
        节点.nextElementSibling         当前节点的最后一个兄弟元素节点

	操作节点：
 		document.createElement()               创建节点
		节点.innerHTML                          在节点内添加或者替换内容（文本和标签）
        节点.innerText                          在节点内添加或者替换内容（文本）
        父节点.appendChild(新节点)               将新节点作为子元素添加到父节点的末尾
        父节点.insertBefore(新节点，目标节点)      将新节点作为父节点的子元素插入到目标节点之前
        父节点.cloneNode()                       克隆节点
                                                   参数为ture 将节点自身及其内部所有节点都复制
                                                   参数为false 仅复制节点本身（默认false）
		父节点.removeChild(需要删除的节点)         通过父节点删除子节点
		
JQ：
    $(父节点).append(新节点)      往父节点内部的末尾添加子节点
    $(新节点).appendTo(父节点)    把新节点添加到父节点内(末尾)
    $(新节点).prepend(新节点)     往父节点内部的开头添加子节点
    $(新节点).prependTo(父节点)   把新节点添加到父节点内的开头
    $(节点).before(新节点)        在节点之前添加兄弟节点
    $(节点).after(新节点)         在节点之后添加兄弟节点
    $(节点).remove()             删除自身及其内部的所有节点
    $(节点).empty()              清空自身内部的所有节点，保留自身
```



#### 18、什么是虚拟dom

	解释：
		虚拟 DOM，其实就是对象，他是用来描述真实dom的js对象，用对象的方式取代真实的 DOM 操作，把真实的 DOM  操作放在内存当中，在内存中的对象里做模拟操作。
	当页面打开时浏览器会解析 HTML 元素，构建一颗 DOM 树，将状态全部保存起来，在内存当中模拟我们真实的 DOM 操作，操作完后又会生成一颗 dom 树，两颗 DOM 树进行比较，根据 diff 算法比较两颗 DOM 树不同的地方，只渲染一次不同的地方。
	
	实现：
		 ①用js对象构造一个虚拟的dom树，插入到文档中；
	     ②状态变更时，记录新树和旧树的差异；
	     ③把上面的差异构建到真正的dom中。
	
	为什么：
		因为真实dom非常消耗性能





#### 19、key值的作用


	作用：
		给每个节点做一个唯一标识
	好处：
		diff算法可以正确识别，更加准确，提高性能
	
	key为什么最好不用index：
		使用index会消耗性能，并且在对数据的逆序添加、逆序删除等破坏顺序操作会对应不上
	    只是用于渲染列表用于展示，使用index作为key是没有问题的。



#### 20、vue首次加载慢

```
减小入口文件积 （如路由懒加载）
静态资源本地缓存
UI框架按需加载
图片资源的压缩
```



#### 21、scoped原理及样式穿透

```
原理：
	为组件实例生成一个唯一标识，给组件中的每个标签对应的dom元素添加一个标签属性，也就是data-v-xxx
样式穿透：
	deep
	>>>
	插件postCSS

```



#### 22、vuex定义、vuex有哪些模块

```
vuex：vuex是一个专为vue开发的状态管理模式，他是用来存储数据的，项目中的任何一个组件都可以获取到进行修改

vuex模块：
    State：存放数据，可以在这里设置默认的初始状态。
    Getter：对state里的数据进行计算处理的
    Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
    Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
    Module：允许将单一的 Store 拆分为多个 store 

为什么要分模块：
	由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。
```





#### 23、vuex刷新数据丢失怎么解决

```
一种方法是存入缓存里
一种是用插件vuex-persist
```



#### 24、深拷贝浅拷贝  及应用场景

```
浅拷贝：
	浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝
	基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址，新旧对象共享同一块内存
	存在浅拷贝现象：拓展运算符
深拷贝：
	深拷贝会开辟一个新的内存空间，两个对象属性完全相同但是对应两个不同的地址，新旧对象不共享内存

所以有当B对象复制A对象时，如果是浅拷贝，B对象发生改变A对象也会改变，如果是深拷贝，B对象发生改变A不会发生改变
深拷贝的方式：
	JSON.stringify()  （弊端：忽略undefined、symbol和函数）
	循环递归
	jQuery.extend()
```



#### 25、堆和栈

	两者都是存放临时数据的地方。
	栈：栈是先进后出的，就像一个桶，后进去的先出来，由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。
	堆：堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。一般由程序员分配释放
	
	• 基本类型变量（Number 、Boolean、Undefined、String、Null）的值一般都是存在栈内存中，
	• 引用类型变量（Array、Object、Function）的值存储在堆内存中，栈内存存储对应空间地址


​	


​	

#### 25、vue生命周期

```
beforeCreated()
第一个生命周期钩子，在 Vue 实例初始化后，创建组件前，立即被调用，（尚未设置计算属性，观察者，事件，数据属性和操作等内容）
created()
第二个生命周期钩子，在这个阶段，已经设置了计算属性，观察者，事件，数据属性和操作，但 Vue 实例尚未挂载到页面上
beforeMount()
这是在 DOM 上挂载实例之前的那一刻，模板已经编译（data 中的数据和模板生成 html），但无法操作 DOM
mounted()
挂载完成后（模板渲染到了页面中）,请求数据一般也在这里进行，DOM 的操作放在这里
beforeUpdate()
数据更新前调用
updated()
当数据发生改变后，被调用
beforeDestroy()
在 Vue 实例被销毁之前，被调用
destroyed()
这是最后一个生命周期钩子，所有的子 Vue 实例都已经被销毁。


父子组件生命周期顺序：
父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted
```





#### 26、什么是this

```
关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象
```



#### 26.5、什么是构造函数

```
构造函数 ，是⼀种特殊的⽅法。主要⽤来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符⼀起使⽤在创建对象的语句中。
```



#### 27、new具体干了什么

```
①在内存中创建一个新的空对象
②让this指向这个新的对象
③执行构造函数里面的代码，给这个新对象添加属性和方法
④返回这个新对象（所以构造函数里面不需要return）
```



#### 28、什么是nexttick，作用

获取更新后的DOM的Vue方法

当数据更新了，在dom中渲染后，自动执行该函数



#### 29、改变this指向

```
call、apply、bind三种方法，他们都是改变函数执行时的上下文，也就是this指向的
他们的第一个参数都是this指向，第二个都是用来接收参数的，apply是以数组形式接收，call和bind都是参数列表，但bind可以分多次传入
apply和call都是改变this指向后函数会立即执行，且只临时改变this指向一次，而bind不会立即执行，而是返回一个永久改变this指向的函数
```



#### 30、什么是箭头函数，与普通函数的区别

```
区别：
    1、外形不同：箭头函数使用箭头定义，普通函数没有
    2、箭头函数全都是匿名函数，普通函数可以有匿名也可以有具名函数
    3、箭头函数不能用于构造函数，普通函数可以用于构造函数
    4、普通函数的this总是指向调用它的对象，而箭头函数没有自己的this，他的this是继承而来，默认指向定义它时所处的对象，而不是执行时的对象，一般是window
```



#### 31、路由模式 （hash和history）

```
在hash模式下，所有的页面跳转都是客户端进行操作，因此对于页面拦截更加灵活；但每次url的改变不属于一次http请求，所以不利于SEO优化。
在history模式下，借助history.pushState实现页面的无刷新跳转；这种方式URL的改变属于http请求，因此会重新请求服务器
```



#### 32、路由钩子

```
① 全局导航钩子：一般用来判断权限，以及页面丢失时需要执行的操作；
beforeEach（）每次路由进入之前执行的函数。
afterEach（）每次路由进入之后执行的函数。
beforeResolve（）2.5 新增
② 单个路由（实例钩子）：某个指定路由跳转时需要执行的逻辑。
beforeEnter（）
beforeLeave（）
③ 组件路由钩子：
beforeRouteEnter（）
beforeRouteLeave（）
beforeRouteUpdate（）

```



#### 33、路由跳转方式、路由传参

```
1、router-link
	1）不带参数
        <router-link :to="{path:'/home'}"> 
        注意：router-link中链接如果是'/'开始就是从根路由开始，如果开始不带'/'，则从当前路由开始。
	2）带参数
		① params传参数 (类似post)
			<router-link :to="{name:'home', params: {id:1}}">    
            // 路由配置 path: "/home/:id" 或者 path: "/home:id"
            // 不配置path ,第一次可请求,刷新页面id会消失
            // 配置path,刷新页面id会保留
            获取：
            // html 取参 $route.params.id
            // script 取参 this.$route.params.id

		② query传参数 (类似get,url后面会显示参数)
			<router-link :to="{name:'home', query: {id:1}}">
            // 路由可不配置
            获取：
            // html 取参 $route.query.id
            // script 取参 this.$route.query.id

2、方法里
	1）不带参数
		this.$router.push('/home')
	
	2)query传参
		this.$router.push({path:'/home',query:{id:'1'}})
		获取：
			// html 取参 $route.query.id
			// script 取参 this.$route.query.id
	3）params传参
		this.$router.push({name:'home',params: {id:'1'}}) // 只能用 name
		获取：
            // 路由配置 path: "/home/:id" 或者 path: "/home:id" ,
            // 不配置path ,第一次可请求,刷新页面id会消失
            // 配置path,刷新页面id会保留

            // html 取参 $route.params.id
            // script 取参 this.$route.params.id


query和params区别：

query类似 get, 跳转之后页面 url后面会拼接参数,类似?id=1, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在
params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失
```





#### 35、组件间通信方式


	父组件传值给子组件，子组件使用props进行接收
	
	子组件传值给父组件，子组件使用$emit+事件对父组件进行传值
	
	组件中可以使用$parent和$children获取到父组件实例和子组件实例，进而获取数据
	
	使用$attrs和$listeners，在对一些组件进行二次封装时可以方便传值，例如A->B->C
	
	使用$refs获取组件实例，进而获取数据
	
	使用Vuex进行状态管理
	
	使用eventBus进行跨组件触发事件，进而传递数据
	
	使用provide和inject，官方建议我们不要用这个，我在看ElementUI源码时发现大量使用
	
	浏览器本地缓存，例如localStorage







#### 37、同源策略、跨域

```
跨域：
	跨域是同源策略导致的，同源策略就是协议、域名、端口号一致，如果有一个不一致的话就会产生跨域

解决：
	JSONP（只适用于get请求）
	CORS（后端）
	vue动态代理proxy
```



#### 38、什么是同步什么是异步、及场景

```
同步：在主线程上排队执行的任务，这些任务就需要进行排队，前一个任务执行完，才会执行下一个任务
异步：不进入主线程，进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了才会进入主线程
同步场景：网站的渲染过程
异步场景：图片的加载、定时器、发送请求
异步任务还被分为了两类，宏任务和微任务，宏任务ajax请求、定时器，微任务promise.then，promise.catch ，process.nexTick，微任务先执行
```



#### 39、节流和防抖

```
节流: n 秒内只运行一次，若在 n 秒内重复触发，只生效一次
防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时
节流场景：滚动加载
防抖场景：搜索框搜索输入。只需用户最后一次输入完，再发送请求
```



#### 40、重绘和重排（回流）

```
回流：当渲染树中的节点信息发生了大小、边距等问题，需要重新计算各节点和css具体的大小和位置。如：weight、height等
重绘：当节点的部分属性发生变化，但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程，就叫重绘。比如：改变元素的背景颜色、字体颜色等操作会造成重绘。
回流的过程在重绘的过程前面，所以回流一定会重绘，但重绘不一定会引起回流。
```



#### 41、什么是nodejs

```
它是一套 JavaScript 运行环境，用来支持 JavaScript 代码的执行。
```



#### 42、slot组件

```
插槽用于决定将所携带的内容，插入到子组件指定的某个位置，但内容必须在父组件中子组件的标签内定义，在子组件中用标签接收。slot 是组件内部的占位符。
```



#### 43、缓存

```
localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据  用于保存重要数据
 sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的。浏览器一旦关闭，数据就销毁了
cookie：一般由服务器生成，可以设置失效时间；若没有设置时间，关闭浏览器cookie失效，若设置了时间，cookie就会存放在硬盘里，过期才失效   用于保存登录信息或者一些
```





#### 45、es6新特性


	let const  箭头函数  解构赋值  扩展运算符 剩余参数  set()，map对象  
	模板字符串  promise对象  async和await (ES7)   Array.from() 和 Array.of()  对象简写
	数组的迭代方法：map foreach every some reduce find findindex filter  object.assign方法 is方法
	（assign 浅拷贝同名替换处理数组处理取值函数）
	函数可以设置默认参数 for...of  for…in循环  新增了class类  模块化
	（exprot default // 导出     import modA from './a.js' // 引入模块）

#### 46、css3新特性

```
新增了一些选择器
border-radius：创建圆角边框
box-shadow：为元素添加阴影
transform 转换
animation 动画
linear-gradient：线性渐变
radial-gradient：径向渐变
弹性布局
```



#### 47、html5新特性

```
语义标签
video和audio
canvas绘图
svg绘图
表单的一些属性（选取颜色、日期、月份、时间）
```



#### 48、如何画一个三角形

```css
width:0;
height:0;
margin: 100px auto;
border-left:10px solid transparent;
border-right:10px solid transparent;
border-top:10px solid black;
border-bottom:10px solid black;
```



#### 49、什么是双飞翼布局、圣杯布局

双飞翼：利用自身margin外边距

1. 是三列布局，两边固定宽度，中间自适应
2. 中间内容元素在 dom 元素次序中优先位置

圣杯：利用父级padding内边距

1. 是三列布局，两边固定宽度，中间自适应
2. 中间内容元素在 dom 元素次序中优先位置

#### 50、让元素居中的几种方式

```
1、margin： 0 auto
2、父 text-align：center
3、line-height
4、弹性盒子flex
	justify-content: center;
    align-items: center;
5、使用绝对定位并进行偏移
6、元素宽高不确定transform: translate(-50%,-50%);
```



#### 51、map、set容器

1、set

set以RBTree作为底层容器
所得元素的只有key没有value，value就是key
不允许出现键值重复
所有的元素都会被自动排序
不能通过迭代器来改变set的值，因为set的值就是键
2、map

map以RBTree作为底层容器
所有元素都是键+值存在
不允许键重复
所有元素是通过键进行自动排序的
map的键是不能修改的，但是其键对应的值是可以修改的

#### 52、for of、for in、foreach、map方法

for in
   1循环[遍历](https://so.csdn.net/so/search?q=遍历&spm=1001.2101.3001.7020)的值都是数据结构的键值,它可以循环数组也能循环对象.,
   2.它遍历数元素的时候,还会遍历其他新增的属性,
   3.在有些情况下,还会以随机顺序遍历数组
   4.所以他最好用来遍历对象

for of 
    1.可以避免for in循环中的陷阱
    2.不同于forEach,它可以使用return,break,continue来终止循环
    3.它不仅仅支持数组的遍历,同时也适用于很多类似数组的对象
    4.还可遍历字符串
    5.并不能处理原有的而原生对象
    6.他不能遍历一个普通的对象,只有在对象中部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环
    7.如果不部署Symbol.iterator 属性,想遍历普通对象,需要联合Object.keys()来使用

forEach
    1.他不能使用return,break,continue来终止循环,
    2.在回调函数内不管传入任何形式 的参数,都会返回undifind
    3.在回调函数内部有三个参数,item,index,arr分别代表,当前项,当前项的下标,数组本身.
    4.它会对数组的每一个元素执行一次提供的函数,不改变原数组,没有返回值undifind

```
for of	是用来遍历键值的，返回属性值
for in	是用来遍历键名的，返回索引值
forEach	没有返回值，他不会生成新数组，原数组会改变
map		返回的是数组的每一项，他会产生新数组，原数组不会改变
```



#### 53、==和===

== 等于(值)  ===全等于(值，数据类型)

#### 54、如何判断数据类型，他们的区别

```
1、typeof：判断基本数据类型，返回数据类型 （判断null和引用类型都为objec）
2、instanceof：返回true和false
3、isArray 判断是否为数组 （JQ）
```

 

 

#### 55、data为什么是一个函数

	组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果





#### 56、computed、method、watch

```
methods：是个方法，写业务逻辑，是对函数调用，不具有缓存机制，每次都要重新计算
computed：是对data数据做计算的，并且computed具有缓存机制，她是对属性调用，不能进行异步操作
watch：是监听某一个变量的变化，可以进行异步操作，他有两个属性，deep是深度监听
immediate 因为第一次加载的时候是不监听的，这个可以让他第一次加载就监听

```



#### 57、优化vue速度

```
不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）
v-if 和 v-show 区分使用场景
computed 和 watch 区分使用场景
v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if
防止内部泄漏，组件销毁后把全局变量和事件销毁
图片懒加载
路由懒加载
第三方插件的按需引入
适当采用 keep-alive 缓存组件
防抖、节流运用


```



#### 58、webpack 的作用

1、是一个模块化打包工具,将不同的资源和文件,进行打包,合并在一个文件里。

2、重新加载编译,将浏览器不认识的语法编译成浏览器认识的语法。less编译成css,ES6语法转换成ES5。



#### 59、diff算法

```
diff 算法是一种通过同层的树节点进行比较的高效算法

其有两个特点：

比较只会在同层级进行, 不会跨层级比较
在diff比较的过程中，循环从两边向中间比较
diff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较
```



#### 60、data和props的区别，props怎么设置类型

1、data不需要用户（开发者）传值，自身维护；而props需要用户（开发者）传值。

2、data上的数据都是可读可写的；而props上的数据只可以读的，无法重新赋值。

```
data是每个组件的私有内存，可以在其中存储需要的任何变量。
props是将数据从父组件传递到子组件的方式。
prop为什么是单向的：为了防止从子组件意外变更父级组件的状态
props设置类型：通过type属性
			props:{
				propA:{
					type:String
				},
				propB:{
					type:Array
				}
			}
```



#### 61、route和router

	route 是“路由信息对象”，包括 path,params,hash,query,fullPath,matched,name 等路由信息参数。
	router 是“路由实例对象”，包括了路由的跳转方法(push、go)，钩子函数等。


​	

#### 62、递归

一个函数不断引用自身，直到引用的唯一已知对象时止的过程

#### 63、响应式数据

1.对象属性拦截(vue2.x)

Object.defineProperty

2.对象整体代理(vue3.x)

Proxy

#### 64、不同状态码

100-199 用于指定客户端应相应的某些动作。

200-299 用于表示请求成功。

300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。

400-499 用于指出客户端的错误。

500-599 用于支持服务器错误。

 

#### 65、冒泡

 当元素触发事件的时候，事件会先从window中，一层层的往下寻找目标元素，找到目标元素以后又回到window

 

#### 66、在js当中创建对象有哪几种方式

1.利用 new Object()创建对象

2.利用对象字面量创建 对象字面量:就是花括号{}里面包含了表达这个具体事物(对象)的属性和方法。

3.利用构造函数创建 

 

#### 67、let const var

1. var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。
2. let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
3. const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。

```
var 、let都是声明变量的

1、let避免了变量提升
2、var具有函数作用域 let具有块级作用域  （只要有大括号都叫做块级作用域）
3、var 可以重复声明一个变量，let不可以
4、const拥有let的所有特性，const只能声明常量，声明的同时就要对变量赋值，并且一旦声明不能改变
5、const声明对象,可以修改属性值,但是不能修改绑定属性
```



#### 68、垃圾回收机制

每隔一段时间, 执行环境都会清理内存中一些没用的变量释放它所占用的内存 

 

 

#### 69、v-model的使用

 

v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：

v-bind绑定一个value属性；

v-on指令给当前元素绑定input事件。

 

 

 

#### 70、浏览器兼容问题

浏览器分为标准浏览器（火狐，谷歌，IE9+）和非标准浏览器(IE6,7,8)

兼容问题产生原因在于浏览器对HTML5和CSS3,ES6标准支持的程度不同

CSS3动画低版本浏览器不支持，解决：用JS, GIF动画

低版本浏览器不支持ES6,ES7一些新特性，解决：使用babel转为ES5

低版本浏览器不支持vue, 使用jquery或原始JS





#### 71、vue封装组件

```
先创建组件，把需要从父组件接收的数据通过props接收，要传递给父组件的数据通过$emit传递
在需要用组件的地方注册该组件

```



#### 72、router钩子守卫

全局前置守卫 router.beforeEach

全局解析守卫 router.beforeResolve

全局后置钩子router.afterEach



#### 73、element-ui Table表格加载数据过多时，页面会很卡，怎么处理

```
pl-table：pl-table是基于element ui的一个大数据表格插件
```



#### 74、echarts 随屏幕大小改变大小

```
1）绑定resize事件
this.$refs.myChart.resize
2）多个图表用resize会报错，需先判断
if(this.$refs.myChart)this.$refs.myChart.resizee();
if(this.$refs.myChart2)this.$refs.myChart2.resizee();
if(this.$refs.myChart3)this.$refs.myChart3.resizee();
```



#### 75、切换其他统计图时，出现卡顿或者数据还存在的问题,怎么办？

```
1.把返回的数据清空

2.销毁这个统计图的资源；

clear()方法则是清空图例数据，不影响图例的resize，而且能够释放内存
beforeDestroy () {this.chart.clear()},
```



#### 76、行内元素、块级元素、行内块元素

```
块级元素 	  可以设置宽高，独占一行 div、h1-h6、p、ul、li、ol、table、form等
行内元素 	  不可以设置宽高，同行显示 span、a、i、em、b、strong、u、del
行内块元素 	 既可以设置宽高又可以同行显示 img、form内所有（input、button、select、textarea）
```



#### 77、keep-alive组件

```
是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。 
<keep-alive>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
使用场景：列表页点击某一个信息跳转到详情，返回后仍显示原有信息
```



#### 78、js继承有哪几种方式

```
1、原型继承
2、盗用构造函数
3、组合继承
4、原型式继承
5、寄生式继承
6、寄生式组合继承
```



#### 79、遍历对象的方法

```
Object.values
Object.keys
Object.entries
```



#### 80、如何去重

```
set方法：
        var arr = [28,55,35,72,12,55,28,7]
        let mySet = new Set(arr)
        let arr2 = Array.from(mySet)
for循环：  
        for(var i=0;i<arr.length;i++){
            if(newArr.indexOf(arr[i])==-1){//不存在
                //将他添加到新数组内
                newArr.push(arr[i])
            }
        }
```



#### 81、css、less、sass（scss）

```
css可以直接被html引用,但是sass和less由于使用了类似JavaScript的方式去书写,所以必须要经过编译生成css
less、sass增加了规则、变量、混入、选择器、继承等特性
```



#### 82、怎么用css设置字体小于12px

```
transform: scale(0.8);//缩放0.8
```



#### 83、v-if和v-for是不能一起使用的，为什么？如果想一起使用该如何解决

```
原因：在处于同一节点的时候，v-for 优先级比 v-if 高。所以 v-if 将分别重复运行于每个 v-for 循环中。
解决：
	1、template
	
	2、计算属性
```



#### 84、css的盒模型

```
1）box-sizing:content-box标准盒模型
    内容就是盒子的边界 
    盒宽 = width + border（左右） + padding（左右）
    盒高 = height + border（上下） + padding（上下）
2）box-sizing:border-box怪异盒模型（ie盒模型）
    边框才是盒子的边界。
    盒宽 = width
    盒高 = height


```



#### 85、git的指令

```
git config
git clone		克隆
git init		初始化仓库
git status		查看本地仓库状态
git branch		操作git分值命令
git checkout	切换分支
git add			提交文件
git commit		将暂存区中的文件提交到本地仓库中
git diff		比较版本之间的差异
git pull		拉取远程仓库
git push		提交本地仓库

```



#### 86、方法是写在原型上还是写在构造函数里

```
原型里
```

